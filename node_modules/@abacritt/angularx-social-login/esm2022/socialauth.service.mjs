import { Inject, Injectable } from '@angular/core';
import { AsyncSubject, isObservable, ReplaySubject } from 'rxjs';
import { GoogleLoginProvider } from './providers/google-login-provider';
import * as i0 from "@angular/core";
/**
 * The service encapsulating the social login functionality. Exposes methods like
 * `signIn`, `signOut`. Also, exposes an `authState` `Observable` that one can
 * subscribe to get the current logged in user information.
 *
 * @dynamic
 */
export class SocialAuthService {
    static { this.ERR_LOGIN_PROVIDER_NOT_FOUND = 'Login provider not found'; }
    static { this.ERR_NOT_LOGGED_IN = 'Not logged in'; }
    static { this.ERR_NOT_INITIALIZED = 'Login providers not ready yet. Are there errors on your console?'; }
    static { this.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN = 'Chosen login provider is not supported for refreshing a token'; }
    static { this.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN = 'Chosen login provider is not supported for getting an access token'; }
    /** An `Observable` that one can subscribe to get the current logged in user information */
    get authState() {
        return this._authState.asObservable();
    }
    /** An `Observable` to communicate the readiness of the service and associated login providers */
    get initState() {
        return this._initState.asObservable();
    }
    /**
     * @param config A `SocialAuthServiceConfig` object or a `Promise` that resolves to a `SocialAuthServiceConfig` object
     */
    constructor(config, _ngZone, _injector) {
        this._ngZone = _ngZone;
        this._injector = _injector;
        this.providers = new Map();
        this.autoLogin = false;
        this._user = null;
        this._authState = new ReplaySubject(1);
        /* Consider making this an enum comprising LOADING, LOADED, FAILED etc. */
        this.initialized = false;
        this._initState = new AsyncSubject();
        if (config instanceof Promise) {
            config.then((config) => {
                this.initialize(config);
            });
        }
        else {
            this.initialize(config);
        }
    }
    initialize(config) {
        this.autoLogin = config.autoLogin !== undefined ? config.autoLogin : false;
        const { onError = console.error } = config;
        config.providers.forEach((item) => {
            this.providers.set(item.id, 'prototype' in item.provider
                ? this._injector.get(item.provider)
                : item.provider);
        });
        Promise.all(Array.from(this.providers.values()).map((provider) => provider.initialize(this.autoLogin)))
            .then(() => {
            if (this.autoLogin) {
                const loginStatusPromises = [];
                let loggedIn = false;
                this.providers.forEach((provider, key) => {
                    const promise = provider.getLoginStatus();
                    loginStatusPromises.push(promise);
                    promise
                        .then((user) => {
                        this.setUser(user, key);
                        loggedIn = true;
                    })
                        .catch(console.debug);
                });
                Promise.all(loginStatusPromises).catch(() => {
                    if (!loggedIn) {
                        this._user = null;
                        this._authState.next(null);
                    }
                });
            }
            this.providers.forEach((provider, key) => {
                if (isObservable(provider.changeUser)) {
                    provider.changeUser.subscribe((user) => {
                        this._ngZone.run(() => {
                            this.setUser(user, key);
                        });
                    });
                }
            });
        })
            .catch((error) => {
            onError(error);
        })
            .finally(() => {
            this.initialized = true;
            this._initState.next(this.initialized);
            this._initState.complete();
        });
    }
    async getAccessToken(providerId) {
        const providerObject = this.providers.get(providerId);
        if (!this.initialized) {
            throw SocialAuthService.ERR_NOT_INITIALIZED;
        }
        else if (!providerObject) {
            throw SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND;
        }
        else if (!(providerObject instanceof GoogleLoginProvider)) {
            throw SocialAuthService.ERR_NOT_SUPPORTED_FOR_ACCESS_TOKEN;
        }
        return await providerObject.getAccessToken();
    }
    refreshAuthToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject) {
                    if (typeof providerObject.refreshToken !== 'function') {
                        reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
                    }
                    else {
                        providerObject
                            .refreshToken()
                            .then((user) => {
                            this.setUser(user, providerId);
                            resolve();
                        })
                            .catch((err) => {
                            reject(err);
                        });
                    }
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    refreshAccessToken(providerId) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (providerId !== GoogleLoginProvider.PROVIDER_ID) {
                reject(SocialAuthService.ERR_NOT_SUPPORTED_FOR_REFRESH_TOKEN);
            }
            else {
                const providerObject = this.providers.get(providerId);
                if (providerObject instanceof GoogleLoginProvider) {
                    providerObject.revokeAccessToken().then(resolve).catch(reject);
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign in a user with a specific `LoginProvider`.
     *
     * @param providerId Id with which the `LoginProvider` has been registered with the service
     * @param signInOptions Optional `LoginProvider` specific arguments
     * @returns A `Promise` that resolves to the authenticated user information
     */
    signIn(providerId, signInOptions) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else {
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signIn(signInOptions)
                        .then((user) => {
                        this.setUser(user, providerId);
                        resolve(user);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    /**
     * A method used to sign out the currently loggen in user.
     *
     * @param revoke Optional parameter to specify whether a hard sign out is to be performed
     * @returns A `Promise` that resolves if the operation is successful, rejects otherwise
     */
    signOut(revoke = false) {
        return new Promise((resolve, reject) => {
            if (!this.initialized) {
                reject(SocialAuthService.ERR_NOT_INITIALIZED);
            }
            else if (!this._user) {
                reject(SocialAuthService.ERR_NOT_LOGGED_IN);
            }
            else {
                let providerId = this._user.provider;
                let providerObject = this.providers.get(providerId);
                if (providerObject) {
                    providerObject
                        .signOut(revoke)
                        .then(() => {
                        resolve();
                        this.setUser(null);
                    })
                        .catch((err) => {
                        reject(err);
                    });
                }
                else {
                    reject(SocialAuthService.ERR_LOGIN_PROVIDER_NOT_FOUND);
                }
            }
        });
    }
    setUser(user, id) {
        if (user && id)
            user.provider = id;
        this._user = user;
        this._authState.next(user);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "17.0.6", ngImport: i0, type: SocialAuthService, deps: [{ token: 'SocialAuthServiceConfig' }, { token: i0.NgZone }, { token: i0.Injector }], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "17.0.6", ngImport: i0, type: SocialAuthService, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.6", ngImport: i0, type: SocialAuthService, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: () => [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['SocialAuthServiceConfig']
                }] }, { type: i0.NgZone }, { type: i0.Injector }] });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic29jaWFsYXV0aC5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vcHJvamVjdHMvbGliL3NyYy9zb2NpYWxhdXRoLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLE1BQU0sRUFBRSxVQUFVLEVBQTBCLE1BQU0sZUFBZSxDQUFDO0FBQzNFLE9BQU8sRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFjLGFBQWEsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUc3RSxPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQzs7QUFXeEU7Ozs7OztHQU1HO0FBRUgsTUFBTSxPQUFPLGlCQUFpQjthQUNKLGlDQUE0QixHQUNsRCwwQkFBMEIsQUFEd0IsQ0FDdkI7YUFDTCxzQkFBaUIsR0FBRyxlQUFlLEFBQWxCLENBQW1CO2FBQ3BDLHdCQUFtQixHQUN6QyxrRUFBa0UsQUFEekIsQ0FDMEI7YUFDN0Msd0NBQW1DLEdBQ3pELCtEQUErRCxBQUROLENBQ087YUFDMUMsdUNBQWtDLEdBQ3hELG9FQUFvRSxBQURaLENBQ2E7SUFZdkUsMkZBQTJGO0lBQzNGLElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRUQsaUdBQWlHO0lBQ2pHLElBQUksU0FBUztRQUNYLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUN4QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxZQUVFLE1BQWtFLEVBQ2pELE9BQWUsRUFDZixTQUFtQjtRQURuQixZQUFPLEdBQVAsT0FBTyxDQUFRO1FBQ2YsY0FBUyxHQUFULFNBQVMsQ0FBVTtRQTNCOUIsY0FBUyxHQUErQixJQUFJLEdBQUcsRUFBRSxDQUFDO1FBQ2xELGNBQVMsR0FBRyxLQUFLLENBQUM7UUFFbEIsVUFBSyxHQUFzQixJQUFJLENBQUM7UUFDaEMsZUFBVSxHQUFxQyxJ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QUNuQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQztRQUNsQixJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUM3QixDQUFDOzhHQXpPVSxpQkFBaUIsa0JBbUNsQix5QkFBeUI7a0hBbkN4QixpQkFBaUIsY0FESixNQUFNOzsyRkFDbkIsaUJBQWlCO2tCQUQ3QixVQUFVO21CQUFDLEVBQUUsVUFBVSxFQUFFLE1BQU0sRUFBRTs7MEJBb0M3QixNQUFNOzJCQUFDLHlCQUF5QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE5nWm9uZSwgVHlwZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBBc3luY1N1YmplY3QsIGlzT2JzZXJ2YWJsZSwgT2JzZXJ2YWJsZSwgUmVwbGF5U3ViamVjdCB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyBMb2dpblByb3ZpZGVyIH0gZnJvbSAnLi9lbnRpdGllcy9sb2dpbi1wcm92aWRlcic7XHJcbmltcG9ydCB7IFNvY2lhbFVzZXIgfSBmcm9tICcuL2VudGl0aWVzL3NvY2lhbC11c2VyJztcclxuaW1wb3J0IHsgR29vZ2xlTG9naW5Qcm92aWRlciB9IGZyb20gJy4vcHJvdmlkZXJzL2dvb2dsZS1sb2dpbi1wcm92aWRlcic7XHJcblxyXG4vKipcclxuICogQW4gaW50ZXJmYWNlIHRvIGRlZmluZSB0aGUgc2hhcGUgb2YgdGhlIHNlcnZpY2UgY29uZmlndXJhdGlvbiBvcHRpb25zLlxyXG4gKi9cclxuZXhwb3J0IGludGVyZmFjZSBTb2NpYWxBdXRoU2VydmljZUNvbmZpZyB7XHJcbiAgYXV0b0xvZ2luPzogYm9vbGVhbjtcclxuICBwcm92aWRlcnM6IHsgaWQ6IHN0cmluZzsgcHJvdmlkZXI6IExvZ2luUHJvdmlkZXIgfCBUeXBlPExvZ2luUHJvdmlkZXI+IH1bXTtcclxuICBvbkVycm9yPzogKGVycm9yOiBhbnkpID0+IGFueTtcclxufVxyXG5cclxuLyoqXHJcbiAqIFRoZSBzZXJ2aWNlIGVuY2Fwc3VsYXRpbmcgdGhlIHNvY2lhbCBsb2dpbiBmdW5jdGlvbmFsaXR5LiBFeHBvc2VzIG1ldGhvZHMgbGlrZVxyXG4gKiBgc2lnbkluYCwgYHNpZ25PdXRgLiBBbHNvLCBleHBvc2VzIGFuIGBhdXRoU3RhdGVgIGBPYnNlcnZhYmxlYCB0aGF0IG9uZSBjYW5cclxuICogc3Vic2NyaWJlIHRvIGdldCB0aGUgY3VycmVudCBsb2dnZWQgaW4gdXNlciBpbmZvcm1hdGlvbi5cclxuICpcclxuICogQGR5bmFtaWNcclxuICovXHJcbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXHJcbmV4cG9ydCBjbGFzcyBTb2NpYWxBdXRoU2VydmljZSB7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCA9XHJcbiAgICAnTG9naW4gcHJvdmlkZXIgbm90IGZvdW5kJztcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX0xPR0dFRF9JTiA9ICdOb3QgbG9nZ2VkIGluJztcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX0lOSVRJQUxJWkVEID1cclxuICAgICdMb2dpbiBwcm92aWRlcnMgbm90IHJlYWR5IHlldC4gQXJlIHRoZXJlIGVycm9ycyBvbiB5b3VyIGNvbnNvbGU/JztcclxuICBwcml2YXRlIHN0YXRpYyByZWFkb25seSBFUlJfTk9UX1NVUFBPUlRFRF9GT1JfUkVGUkVTSF9UT0tFTiA9XHJcbiAgICAnQ2hvc2VuIGxvZ2luIHByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIHJlZnJlc2hpbmcgYSB0b2tlbic7XHJcbiAgcHJpdmF0ZSBzdGF0aWMgcmVhZG9ubHkgRVJSX05PVF9TVVBQT1JURURfRk9SX0FDQ0VTU19UT0tFTiA9XHJcbiAgICAnQ2hvc2VuIGxvZ2luIHByb3ZpZGVyIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGdldHRpbmcgYW4gYWNjZXNzIHRva2VuJztcclxuXHJcbiAgcHJpdmF0ZSBwcm92aWRlcnM6IE1hcDxzdHJpbmcsIExvZ2luUHJvdmlkZXI+ID0gbmV3IE1hcCgpO1xyXG4gIHByaXZhdGUgYXV0b0xvZ2luID0gZmFsc2U7XHJcblxyXG4gIHByaXZhdGUgX3VzZXI6IFNvY2lhbFVzZXIgfCBudWxsID0gbnVsbDtcclxuICBwcml2YXRlIF9hdXRoU3RhdGU6IFJlcGxheVN1YmplY3Q8U29jaWFsVXNlciB8IG51bGw+ID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XHJcblxyXG4gIC8qIENvbnNpZGVyIG1ha2luZyB0aGlzIGFuIGVudW0gY29tcHJpc2luZyBMT0FESU5HLCBMT0FERUQsIEZBSUxFRCBldGMuICovXHJcbiAgcHJpdmF0ZSBpbml0aWFsaXplZCA9IGZhbHNlO1xyXG4gIHByaXZhdGUgX2luaXRTdGF0ZTogQXN5bmNTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xyXG5cclxuICAvKiogQW4gYE9ic2VydmFibGVgIHRoYXQgb25lIGNhbiBzdWJzY3JpYmUgdG8gZ2V0IHRoZSBjdXJyZW50IGxvZ2dlZCBpbiB1c2VyIGluZm9ybWF0aW9uICovXHJcbiAgZ2V0IGF1dGhTdGF0ZSgpOiBPYnNlcnZhYmxlPFNvY2lhbFVzZXI+IHtcclxuICAgIHJldHVybiB0aGlzLl9hdXRoU3RhdGUuYXNPYnNlcnZhYmxlKCk7XHJcbiAgfVxyXG5cclxuICAvKiogQW4gYE9ic2VydmFibGVgIHRvIGNvbW11bmljYXRlIHRoZSByZWFkaW5lc3Mgb2YgdGhlIHNlcnZpY2UgYW5kIGFzc29jaWF0ZWQgbG9naW4gcHJvdmlkZXJzICovXHJcbiAgZ2V0IGluaXRTdGF0ZSgpOiBPYnNlcnZhYmxlPGJvb2xlYW4+IHtcclxuICAgIHJldHVybiB0aGlzLl9pbml0U3RhdGUuYXNPYnNlcnZhYmxlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAcGFyYW0gY29uZmlnIEEgYFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnYCBvYmplY3Qgb3IgYSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byBhIGBTb2NpYWxBdXRoU2VydmljZUNvbmZpZ2Agb2JqZWN0XHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBASW5qZWN0KCdTb2NpYWxBdXRoU2VydmljZUNvbmZpZycpXHJcbiAgICBjb25maWc6IFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnIHwgUHJvbWlzZTxTb2NpYWxBdXRoU2VydmljZUNvbmZpZz4sXHJcbiAgICBwcml2YXRlIHJlYWRvbmx5IF9uZ1pvbmU6IE5nWm9uZSxcclxuICAgIHByaXZhdGUgcmVhZG9ubHkgX2luamVjdG9yOiBJbmplY3RvclxyXG4gICkge1xyXG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIFByb21pc2UpIHtcclxuICAgICAgY29uZmlnLnRoZW4oKGNvbmZpZzogU29jaWFsQXV0aFNlcnZpY2VDb25maWcpID0+IHtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemUoY29uZmlnKTtcclxuICAgICAgfSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLmluaXRpYWxpemUoY29uZmlnKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgaW5pdGlhbGl6ZShjb25maWc6IFNvY2lhbEF1dGhTZXJ2aWNlQ29uZmlnKSB7XHJcbiAgICB0aGlzLmF1dG9Mb2dpbiA9IGNvbmZpZy5hdXRvTG9naW4gIT09IHVuZGVmaW5lZCA/IGNvbmZpZy5hdXRvTG9naW4gOiBmYWxzZTtcclxuICAgIGNvbnN0IHsgb25FcnJvciA9IGNvbnNvbGUuZXJyb3IgfSA9IGNvbmZpZztcclxuXHJcbiAgICBjb25maWcucHJvdmlkZXJzLmZvckVhY2goKGl0ZW0pID0+IHtcclxuICAgICAgdGhpcy5wcm92aWRlcnMuc2V0KFxyXG4gICAgICAgIGl0ZW0uaWQsXHJcbiAgICAgICAgJ3Byb3RvdHlwZScgaW4gaXRlbS5wcm92aWRlclxyXG4gICAgICAgICAgPyB0aGlzLl9pbmplY3Rvci5nZXQoaXRlbS5wcm92aWRlcilcclxuICAgICAgICAgIDogaXRlbS5wcm92aWRlclxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgUHJvbWlzZS5hbGwoXHJcbiAgICAgIEFycmF5LmZyb20odGhpcy5wcm92aWRlcnMudmFsdWVzKCkpLm1hcCgocHJvdmlkZXIpID0+XHJcbiAgICAgICAgcHJvdmlkZXIuaW5pdGlhbGl6ZSh0aGlzLmF1dG9Mb2dpbilcclxuICAgICAgKVxyXG4gICAgKVxyXG4gICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuYXV0b0xvZ2luKSB7XHJcbiAgICAgICAgICBjb25zdCBsb2dpblN0YXR1c1Byb21pc2VzID0gW107XHJcbiAgICAgICAgICBsZXQgbG9nZ2VkSW4gPSBmYWxzZTtcclxuXHJcbiAgICAgICAgICB0aGlzLnByb3ZpZGVycy5mb3JFYWNoKChwcm92aWRlcjogTG9naW5Qcm92aWRlciwga2V5OiBzdHJpbmcpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IHByb3ZpZGVyLmdldExvZ2luU3RhdHVzKCk7XHJcbiAgICAgICAgICAgIGxvZ2luU3RhdHVzUHJvbWlzZXMucHVzaChwcm9taXNlKTtcclxuICAgICAgICAgICAgcHJvbWlzZVxyXG4gICAgICAgICAgICAgIC50aGVuKCh1c2VyOiBTb2NpYWxVc2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVzZXIodXNlciwga2V5KTtcclxuICAgICAgICAgICAgICAgIGxvZ2dlZEluID0gdHJ1ZTtcclxuICAgICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAgIC5jYXRjaChjb25zb2xlLmRlYnVnKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgUHJvbWlzZS5hbGwobG9naW5TdGF0dXNQcm9taXNlcykuY2F0Y2goKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWxvZ2dlZEluKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fdXNlciA9IG51bGw7XHJcbiAgICAgICAgICAgICAgdGhpcy5fYXV0aFN0YXRlLm5leHQobnVsbCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5wcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIsIGtleSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGlzT2JzZXJ2YWJsZShwcm92aWRlci5jaGFuZ2VVc2VyKSkge1xyXG4gICAgICAgICAgICBwcm92aWRlci5jaGFuZ2VVc2VyLnN1YnNjcmliZSgodXNlcikgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuX25nWm9uZS5ydW4oKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5zZXRVc2VyKHVzZXIsIGtleSk7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XHJcbiAgICAgICAgb25FcnJvcihlcnJvcik7XHJcbiAgICAgIH0pXHJcbiAgICAgIC5maW5hbGx5KCgpID0+IHtcclxuICAgICAgICB0aGlzLmluaXRpYWxpemVkID0gdHJ1ZTtcclxuICAgICAgICB0aGlzLl9pbml0U3RhdGUubmV4dCh0aGlzLmluaXRpYWxpemVkKTtcclxuICAgICAgICB0aGlzLl9pbml0U3RhdGUuY29tcGxldGUoKTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICBhc3luYyBnZXRBY2Nlc3NUb2tlbihwcm92aWRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHN0cmluZz4ge1xyXG4gICAgY29uc3QgcHJvdmlkZXJPYmplY3QgPSB0aGlzLnByb3ZpZGVycy5nZXQocHJvdmlkZXJJZCk7XHJcbiAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgdGhyb3cgU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRDtcclxuICAgIH0gZWxzZSBpZiAoIXByb3ZpZGVyT2JqZWN0KSB7XHJcbiAgICAgIHRocm93IFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQ7XHJcbiAgICB9IGVsc2UgaWYgKCEocHJvdmlkZXJPYmplY3QgaW5zdGFuY2VvZiBHb29nbGVMb2dpblByb3ZpZGVyKSkge1xyXG4gICAgICB0aHJvdyBTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX1NVUFBPUlRFRF9GT1JfQUNDRVNTX1RPS0VOO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhd2FpdCBwcm92aWRlck9iamVjdC5nZXRBY2Nlc3NUb2tlbigpO1xyXG4gIH1cclxuXHJcbiAgcmVmcmVzaEF1dGhUb2tlbihwcm92aWRlcklkOiBzdHJpbmcpOiBQcm9taXNlPHZvaWQ+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGlmICghdGhpcy5pbml0aWFsaXplZCkge1xyXG4gICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX0lOSVRJQUxJWkVEKTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zdCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcclxuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcclxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvdmlkZXJPYmplY3QucmVmcmVzaFRva2VuICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTk9UX1NVUFBPUlRFRF9GT1JfUkVGUkVTSF9UT0tFTik7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBwcm92aWRlck9iamVjdFxyXG4gICAgICAgICAgICAgIC5yZWZyZXNoVG9rZW4oKVxyXG4gICAgICAgICAgICAgIC50aGVuKCh1c2VyKSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFVzZXIodXNlciwgcHJvdmlkZXJJZCk7XHJcbiAgICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgcmVmcmVzaEFjY2Vzc1Rva2VuKHByb3ZpZGVySWQ6IHN0cmluZyk6IFByb21pc2U8dm9pZD4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfSU5JVElBTElaRUQpO1xyXG4gICAgICB9IGVsc2UgaWYgKHByb3ZpZGVySWQgIT09IEdvb2dsZUxvZ2luUHJvdmlkZXIuUFJPVklERVJfSUQpIHtcclxuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9TVVBQT1JURURfRk9SX1JFRlJFU0hfVE9LRU4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IHByb3ZpZGVyT2JqZWN0ID0gdGhpcy5wcm92aWRlcnMuZ2V0KHByb3ZpZGVySWQpO1xyXG4gICAgICAgIGlmIChwcm92aWRlck9iamVjdCBpbnN0YW5jZW9mIEdvb2dsZUxvZ2luUHJvdmlkZXIpIHtcclxuICAgICAgICAgIHByb3ZpZGVyT2JqZWN0LnJldm9rZUFjY2Vzc1Rva2VuKCkudGhlbihyZXNvbHZlKS5jYXRjaChyZWplY3QpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX0xPR0lOX1BST1ZJREVSX05PVF9GT1VORCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgbWV0aG9kIHVzZWQgdG8gc2lnbiBpbiBhIHVzZXIgd2l0aCBhIHNwZWNpZmljIGBMb2dpblByb3ZpZGVyYC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSBwcm92aWRlcklkIElkIHdpdGggd2hpY2ggdGhlIGBMb2dpblByb3ZpZGVyYCBoYXMgYmVlbiByZWdpc3RlcmVkIHdpdGggdGhlIHNlcnZpY2VcclxuICAgKiBAcGFyYW0gc2lnbkluT3B0aW9ucyBPcHRpb25hbCBgTG9naW5Qcm92aWRlcmAgc3BlY2lmaWMgYXJndW1lbnRzXHJcbiAgICogQHJldHVybnMgQSBgUHJvbWlzZWAgdGhhdCByZXNvbHZlcyB0byB0aGUgYXV0aGVudGljYXRlZCB1c2VyIGluZm9ybWF0aW9uXHJcbiAgICovXHJcbiAgc2lnbkluKHByb3ZpZGVySWQ6IHN0cmluZywgc2lnbkluT3B0aW9ucz86IGFueSk6IFByb21pc2U8U29jaWFsVXNlcj4ge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLmluaXRpYWxpemVkKSB7XHJcbiAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9OT1RfSU5JVElBTElaRUQpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlck9iamVjdCA9IHRoaXMucHJvdmlkZXJzLmdldChwcm92aWRlcklkKTtcclxuICAgICAgICBpZiAocHJvdmlkZXJPYmplY3QpIHtcclxuICAgICAgICAgIHByb3ZpZGVyT2JqZWN0XHJcbiAgICAgICAgICAgIC5zaWduSW4oc2lnbkluT3B0aW9ucylcclxuICAgICAgICAgICAgLnRoZW4oKHVzZXI6IFNvY2lhbFVzZXIpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLnNldFVzZXIodXNlciwgcHJvdmlkZXJJZCk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh1c2VyKTtcclxuICAgICAgICAgICAgfSlcclxuICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcclxuICAgICAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlamVjdChTb2NpYWxBdXRoU2VydmljZS5FUlJfTE9HSU5fUFJPVklERVJfTk9UX0ZPVU5EKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQSBtZXRob2QgdXNlZCB0byBzaWduIG91dCB0aGUgY3VycmVudGx5IGxvZ2dlbiBpbiB1c2VyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHJldm9rZSBPcHRpb25hbCBwYXJhbWV0ZXIgdG8gc3BlY2lmeSB3aGV0aGVyIGEgaGFyZCBzaWduIG91dCBpcyB0byBiZSBwZXJmb3JtZWRcclxuICAgKiBAcmV0dXJucyBBIGBQcm9taXNlYCB0aGF0IHJlc29sdmVzIGlmIHRoZSBvcGVyYXRpb24gaXMgc3VjY2Vzc2Z1bCwgcmVqZWN0cyBvdGhlcndpc2VcclxuICAgKi9cclxuICBzaWduT3V0KHJldm9rZTogYm9vbGVhbiA9IGZhbHNlKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICBpZiAoIXRoaXMuaW5pdGlhbGl6ZWQpIHtcclxuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9JTklUSUFMSVpFRCk7XHJcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3VzZXIpIHtcclxuICAgICAgICByZWplY3QoU29jaWFsQXV0aFNlcnZpY2UuRVJSX05PVF9MT0dHRURfSU4pO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGxldCBwcm92aWRlcklkID0gdGhpcy5fdXNlci5wcm92aWRlcjtcclxuICAgICAgICBsZXQgcHJvdmlkZXJPYmplY3QgPSB0aGlzLnByb3ZpZGVycy5nZXQocHJvdmlkZXJJZCk7XHJcbiAgICAgICAgaWYgKHByb3ZpZGVyT2JqZWN0KSB7XHJcbiAgICAgICAgICBwcm92aWRlck9iamVjdFxyXG4gICAgICAgICAgICAuc2lnbk91dChyZXZva2UpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICByZXNvbHZlKCk7XHJcbiAgICAgICAgICAgICAgdGhpcy5zZXRVc2VyKG51bGwpO1xyXG4gICAgICAgICAgICB9KVxyXG4gICAgICAgICAgICAuY2F0Y2goKGVycikgPT4ge1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVqZWN0KFNvY2lhbEF1dGhTZXJ2aWNlLkVSUl9MT0dJTl9QUk9WSURFUl9OT1RfRk9VTkQpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIHNldFVzZXIodXNlcjogU29jaWFsVXNlciB8IG51bGwsIGlkPzogc3RyaW5nKSB7XHJcbiAgICBpZiAodXNlciAmJiBpZCkgdXNlci5wcm92aWRlciA9IGlkO1xyXG4gICAgdGhpcy5fdXNlciA9IHVzZXI7XHJcbiAgICB0aGlzLl9hdXRoU3RhdGUubmV4dCh1c2VyKTtcclxuICB9XHJcbn1cclxuIl19